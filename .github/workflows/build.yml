name: Comprehensive Build & Test Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  release:
    types: [published]

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: full
  RUST_LOG: debug

jobs:
  # ============================================================================
  # PRE-BUILD VALIDATION
  # ============================================================================
  
  validate:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgstreamer1.0-dev \
            libgstreamer-plugins-base1.0-dev \
            libglib2.0-dev \
            libgtk-3-dev \
            pkg-config
      
      - uses: dtolnay/rust-toolchain@stable
      
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "crates/summit_hip_numbers"
          cache-on-failure: true
      
      - name: Format Check
        run: cargo fmt --all -- --check
      
      - name: Clippy (All Targets)
        run: cargo clippy --all-targets --all-features -- -D warnings
      
      - name: Unit Tests
        run: cargo test --workspace --verbose
      
      - name: Security Audit
        run: |
          cargo install cargo-audit
          cargo audit
      
      - name: Dependency Check
        run: cargo tree --duplicates

  # ============================================================================
  # WINDOWS BUILD - Full & Demo Variants
  # ============================================================================
  
  build-windows:
    name: Windows Build (${{ matrix.variant }})
    runs-on: windows-latest
    needs: validate
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Build Environment
        id: setup
        shell: pwsh
        run: |
          # Set version from Cargo.toml or git tag
          $version = if ($env:GITHUB_REF -match 'refs/tags/v(.*)') { 
            $matches[1] 
          } else { 
            "dev-$(git rev-parse --short HEAD)" 
          }
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "Building version: $version"
          
          # Create build timestamp
          $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          echo "TIMESTAMP=$timestamp" >> $env:GITHUB_OUTPUT
      
      - name: Cache Cargo Registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-
      
      - name: Setup MSYS2 & GStreamer
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          install: >-
            mingw-w64-x86_64-toolchain
            mingw-w64-x86_64-pkg-config
            mingw-w64-x86_64-glib2
            mingw-w64-x86_64-gstreamer
            mingw-w64-x86_64-gst-plugins-base
            mingw-w64-x86_64-gst-plugins-good
            mingw-w64-x86_64-gst-plugins-bad
            mingw-w64-x86_64-gst-plugins-ugly
            mingw-w64-x86_64-gst-libav
            zip
            unzip
          update: true
          path-type: inherit
      
      - name: Setup Rust GNU Toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable-x86_64-pc-windows-gnu
      
      - name: Comprehensive GStreamer Verification
        shell: msys2 {0}
        run: |
          echo "============================================"
          echo "  COMPREHENSIVE GSTREAMER VERIFICATION"
          echo "============================================"
          
          # Set up environment
          export MSYSTEM=MINGW64
          export MSYSTEM_PREFIX=/mingw64
          export PATH="$MSYSTEM_PREFIX/bin:$PATH"
          export PKG_CONFIG_PATH="/mingw64/lib/pkgconfig:$PKG_CONFIG_PATH"
          
          # Function to check if a command exists
          command_exists() {
            command -v "$1" >/dev/null 2>&1
          }
          
          # Function to check if a file exists
          file_exists() {
            test -f "$1"
          }
          
          # Function to check if a directory exists
          dir_exists() {
            test -d "$1"
          }
          
          echo "1. Checking GStreamer executables..."
          GSTREAMER_TOOLS=(
            "gst-inspect-1.0"
            "gst-launch-1.0"
            "gst-discoverer-1.0"
            "gst-typefind-1.0"
          )
          
          for tool in "${GSTREAMER_TOOLS[@]}"; do
            if command_exists "$tool"; then
              echo "  ✓ $tool: $(which $tool)"
            else
              echo "  ✗ $tool: NOT FOUND"
              exit 1
            fi
          done
          
          echo -e "\n2. Checking core GStreamer libraries..."
          CORE_LIBS=(
            "/mingw64/lib/libgstreamer-1.0.dll.a"
            "/mingw64/lib/libgstbase-1.0.dll.a"
            "/mingw64/lib/libgstapp-1.0.dll.a"
            "/mingw64/lib/libgstvideo-1.0.dll.a"
            "/mingw64/lib/libgstaudio-1.0.dll.a"
          )
          
          for lib in "${CORE_LIBS[@]}"; do
            if file_exists "$lib"; then
              echo "  ✓ $(basename $lib): $(ls -lh $lib | awk '{print $5}')"
            else
              echo "  ✗ $(basename $lib): NOT FOUND"
              exit 1
            fi
          done
          
          echo -e "\n3. Checking runtime DLLs..."
          RUNTIME_DLLS=(
            "/mingw64/bin/libgstreamer-1.0-0.dll"
            "/mingw64/bin/libgstbase-1.0-0.dll"
            "/mingw64/bin/libgstapp-1.0-0.dll"
            "/mingw64/bin/libgstvideo-1.0-0.dll"
            "/mingw64/bin/libgstaudio-1.0-0.dll"
            "/mingw64/bin/libglib-2.0-0.dll"
            "/mingw64/bin/libgobject-2.0-0.dll"
            "/mingw64/bin/libgio-2.0-0.dll"
          )
          
          for dll in "${RUNTIME_DLLS[@]}"; do
            if file_exists "$dll"; then
              echo "  ✓ $(basename $dll): $(ls -lh $dll | awk '{print $5}')"
            else
              echo "  ✗ $(basename $dll): NOT FOUND"
              exit 1
            fi
          done
          
          echo -e "\n4. Checking GStreamer plugin directories..."
          PLUGIN_DIRS=(
            "/mingw64/lib/gstreamer-1.0"
            "/mingw64/bin/gstreamer-1.0"
          )
          
          for plugin_dir in "${PLUGIN_DIRS[@]}"; do
            if dir_exists "$plugin_dir"; then
              plugin_count=$(find "$plugin_dir" -name "*.dll" | wc -l)
              echo "  ✓ $plugin_dir: $plugin_count plugins"
              if [ $plugin_count -lt 10 ]; then
                echo "    WARNING: Low plugin count, checking specific plugins..."
              fi
            else
              echo "  ✗ $plugin_dir: NOT FOUND"
            fi
          done
          
          echo -e "\n5. Verifying essential plugins..."
          ESSENTIAL_PLUGINS=(
            "coreelements"
            "playback"
            "typefindfunctions"
            "app"
            "videoconvert"
            "videoscale"
            "autodetect"
            "directsound"
            "wasapi"
          )
          
          for plugin in "${ESSENTIAL_PLUGINS[@]}"; do
            if gst-inspect-1.0 "$plugin" >/dev/null 2>&1; then
              echo "  ✓ $plugin"
            else
              echo "  ✗ $plugin: NOT AVAILABLE"
              exit 1
            fi
          done
          
          echo -e "\n6. Testing pkg-config integration..."
          if pkg-config --exists gstreamer-1.0; then
            GST_VERSION=$(pkg-config --modversion gstreamer-1.0)
            GST_CFLAGS=$(pkg-config --cflags gstreamer-1.0)
            GST_LIBS=$(pkg-config --libs gstreamer-1.0)
            echo "  ✓ GStreamer version: $GST_VERSION"
            echo "  ✓ CFLAGS: $GST_CFLAGS"
            echo "  ✓ LIBS: $GST_LIBS"
          else
            echo "  ✗ pkg-config cannot find gstreamer-1.0"
            exit 1
          fi
          
          echo -e "\n7. Testing basic GStreamer functionality..."
          if echo "videotestsrc num-buffers=1 ! fakesink" | gst-launch-1.0 >/dev/null 2>&1; then
            echo "  ✓ Basic pipeline test passed"
          else
            echo "  ✗ Basic pipeline test failed"
            exit 1
          fi
          
          echo -e "\n8. Environment summary..."
          echo "  PATH: $PATH"
          echo "  PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
          echo "  MSYSTEM: $MSYSTEM"
          echo "  MSYSTEM_PREFIX: $MSYSTEM_PREFIX"
          
          echo -e "\n============================================"
          echo "  ✅ ALL GSTREAMER CHECKS PASSED"
          echo "============================================"
      
      - name: Create Enhanced Build Script
        shell: msys2 {0}
        run: |
          cat > enhanced_build.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail
          
          VARIANT="$1"
          BUILD_LOG="build_${VARIANT}.log"
          ERROR_LOG="build_${VARIANT}_errors.log"
          
          # Comprehensive logging function
          log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$BUILD_LOG"
          }
          
          error_exit() {
            echo "[ERROR] $*" | tee -a "$ERROR_LOG"
            exit 1
          }
          
          log "Starting enhanced Windows build for variant: $VARIANT"
          
          # Environment setup
          export MSYSTEM=MINGW64
          export MSYSTEM_PREFIX=/mingw64
          export PATH="$MSYSTEM_PREFIX/bin:$PATH"
          export PKG_CONFIG_PATH="/mingw64/lib/pkgconfig:$PKG_CONFIG_PATH"
          export RUSTFLAGS="-L native=/mingw64/lib"
          
          # Create dist directory
          DIST_DIR="dist/$VARIANT"
          mkdir -p "$DIST_DIR"
          
          log "Building application..."
          if [ "$VARIANT" = "demo" ]; then
            cargo build --release --package summit_hip_numbers --features demo 2>&1 | tee -a "$BUILD_LOG"
          else
            cargo build --release --package summit_hip_numbers 2>&1 | tee -a "$BUILD_LOG"
          fi
          
          # Check if build succeeded
          if [ "$VARIANT" = "demo" ]; then
            BINARY_NAME="summit_hip_numbers_demo.exe"
            SOURCE_BINARY="target/release/summit_hip_numbers.exe"
          else
            BINARY_NAME="summit_hip_numbers.exe"
            SOURCE_BINARY="target/release/summit_hip_numbers.exe"
          fi
          
          if [ ! -f "$SOURCE_BINARY" ]; then
            error_exit "Build failed: $SOURCE_BINARY not found"
          fi
          
          log "Copying binary to distribution directory..."
          cp "$SOURCE_BINARY" "$DIST_DIR/$BINARY_NAME"
          
          # Function to safely copy DLL with verification
          copy_dll_safe() {
            local dll_name="$1"
            local source_path="/mingw64/bin/$dll_name"
            local dest_path="$DIST_DIR/$dll_name"
            
            if [ -f "$source_path" ]; then
              cp "$source_path" "$dest_path"
              log "  ✓ Copied: $dll_name ($(stat -c%s "$source_path") bytes)"
            else
              error_exit "Required DLL not found: $source_path"
            fi
          }
          
          log "Copying GStreamer runtime dependencies..."
          
          # Core GLib/GObject DLLs
          GLIB_DLLS=(
            "libglib-2.0-0.dll"
            "libgmodule-2.0-0.dll"
            "libgobject-2.0-0.dll"
            "libgio-2.0-0.dll"
            "libgthread-2.0-0.dll"
            "libffi-8.dll"
            "libintl-8.dll"
            "libiconv-2.dll"
            "libpcre2-8-0.dll"
            "libwinpthread-1.dll"
            "zlib1.dll"
          )
          
          # Core GStreamer DLLs
          GSTREAMER_DLLS=(
            "libgstreamer-1.0-0.dll"
            "libgstbase-1.0-0.dll"
            "libgstcontroller-1.0-0.dll"
            "libgstnet-1.0-0.dll"
            "libgstapp-1.0-0.dll"
            "libgstvideo-1.0-0.dll"
            "libgstaudio-1.0-0.dll"
            "libgstpbutils-1.0-0.dll"
            "libgsttag-1.0-0.dll"
            "libgstriff-1.0-0.dll"
            "libgstfft-1.0-0.dll"
            "libgstrtp-1.0-0.dll"
            "libgstrtsp-1.0-0.dll"
            "libgstsdp-1.0-0.dll"
          )
          
          # Additional system DLLs
          SYSTEM_DLLS=(
            "libgcc_s_seh-1.dll"
            "libstdc++-6.dll"
            "liborc-0.4-0.dll"
          )
          
          # Copy all DLLs with verification
          for dll in "${GLIB_DLLS[@]}" "${GSTREAMER_DLLS[@]}" "${SYSTEM_DLLS[@]}"; do
            copy_dll_safe "$dll"
          done
          
          log "Copying GStreamer plugins..."
          
          # Create plugin directory
          PLUGIN_DIR="$DIST_DIR/lib/gstreamer-1.0"
          mkdir -p "$PLUGIN_DIR"
          
          # Essential plugins for video playback
          ESSENTIAL_PLUGIN_DLLS=(
            "libgstcoreelements.dll"
            "libgstplayback.dll"
            "libgsttypefindfunctions.dll"
            "libgstapp.dll"
            "libgstvideoconvert.dll"
            "libgstvideoscale.dll"
            "libgstvideofilter.dll"
            "libgstautodetect.dll"
            "libgstdirectsound.dll"
            "libgstwasapi.dll"
            "libgstdeinterlace.dll"
            "libgstinterleave.dll"
            "libgstaudioconvert.dll"
            "libgstaudioresample.dll"
            "libgstvolume.dll"
          )
          
          # MP4/H.264 plugins
          MP4_PLUGIN_DLLS=(
            "libgstisomp4.dll"
            "libgstlibav.dll"
            "libgstmatroska.dll"
            "libgstavi.dll"
            "libgstqtdemux.dll"
          )
          
          # Copy plugins with fallback handling
          SOURCE_PLUGIN_DIR="/mingw64/lib/gstreamer-1.0"
          COPIED_PLUGINS=0
          
          for plugin in "${ESSENTIAL_PLUGIN_DLLS[@]}" "${MP4_PLUGIN_DLLS[@]}"; do
            source_plugin="$SOURCE_PLUGIN_DIR/$plugin"
            if [ -f "$source_plugin" ]; then
              cp "$source_plugin" "$PLUGIN_DIR/"
              log "  ✓ Plugin: $plugin"
              ((COPIED_PLUGINS++))
            else
              log "  ⚠ Plugin not found: $plugin"
            fi
          done
          
          if [ $COPIED_PLUGINS -lt 10 ]; then
            error_exit "Too few plugins copied ($COPIED_PLUGINS). Build may not work correctly."
          fi
          
          log "Copied $COPIED_PLUGINS GStreamer plugins"
          
          # Copy additional assets if they exist
          log "Copying additional assets..."
          
          if [ -f "config.toml" ]; then
            cp "config.toml" "$DIST_DIR/"
            log "  ✓ Copied config.toml"
          fi
          
          if [ -d "assets" ]; then
            cp -r "assets" "$DIST_DIR/"
            log "  ✓ Copied assets directory"
          fi
          
          if [ -d "videos" ] && [ "$VARIANT" = "demo" ]; then
            cp -r "videos" "$DIST_DIR/"
            log "  ✓ Copied videos directory (demo)"
          fi
          
          # Set environment for GStreamer
          cat > "$DIST_DIR/gstreamer_env.bat" << 'BATCH_EOF'
          @echo off
          REM Set GStreamer environment for Summit HIP Numbers
          set GST_PLUGIN_PATH=%~dp0lib\gstreamer-1.0
          set GST_PLUGIN_SYSTEM_PATH=%~dp0lib\gstreamer-1.0
          set GST_DEBUG=2
          echo GStreamer environment configured
          echo Plugin path: %GST_PLUGIN_PATH%
          BATCH_EOF
          
          # Create launcher script
          cat > "$DIST_DIR/launch.bat" << BATCH_EOF
          @echo off
          call "%~dp0gstreamer_env.bat"
          "%~dp0$BINARY_NAME" %*
          BATCH_EOF
          
          # Verify the build
          log "Verifying build integrity..."
          
          if [ ! -f "$DIST_DIR/$BINARY_NAME" ]; then
            error_exit "Main executable missing: $BINARY_NAME"
          fi
          
          # Count and verify DLLs
          DLL_COUNT=$(find "$DIST_DIR" -name "*.dll" | wc -l)
          if [ $DLL_COUNT -lt 20 ]; then
            error_exit "Too few DLLs found ($DLL_COUNT). Build incomplete."
          fi
          
          log "Build verification passed: $DLL_COUNT DLLs, $COPIED_PLUGINS plugins"
          
          # Create portable ZIP
          log "Creating portable ZIP archive..."
          cd "$DIST_DIR"
          zip -r "../summit_hip_numbers_${VARIANT}_portable.zip" ./* >/dev/null 2>&1
          cd - >/dev/null
          
          if [ -f "dist/summit_hip_numbers_${VARIANT}_portable.zip" ]; then
            ZIP_SIZE=$(stat -c%s "dist/summit_hip_numbers_${VARIANT}_portable.zip")
            log "✓ Created portable ZIP: summit_hip_numbers_${VARIANT}_portable.zip ($(($ZIP_SIZE / 1024 / 1024)) MB)"
          else
            error_exit "Failed to create portable ZIP"
          fi
          
          log "Enhanced Windows build completed successfully!"
          
          EOF
          
          chmod +x enhanced_build.sh
      
      - name: Execute Enhanced Build
        shell: msys2 {0}
        run: |
          # Run the enhanced build script
          ./enhanced_build.sh ${{ matrix.variant }}
          
          # Display build logs
          echo "============================================"
          echo "  BUILD LOG SUMMARY"
          echo "============================================"
          
          if [ -f "build_${{ matrix.variant }}.log" ]; then
            tail -20 "build_${{ matrix.variant }}.log"
          fi
          
          if [ -f "build_${{ matrix.variant }}_errors.log" ]; then
            echo -e "\nERROR LOG:"
            cat "build_${{ matrix.variant }}_errors.log"
          fi
      
      - name: Upload Build Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: windows-${{ matrix.variant }}-build-logs
          path: |
            build_${{ matrix.variant }}.log
            build_${{ matrix.variant }}_errors.log
          retention-days: 7
          
      
      - name: Generate Build Manifest
        shell: pwsh
        run: |
          $distPath = "dist/${{ matrix.variant }}"
          $manifestPath = "$distPath/BUILD_MANIFEST.txt"
          
          @"
          ================================
          Summit HIP Numbers - Windows Build
          ================================
          Variant: ${{ matrix.variant }}
          Version: ${{ steps.setup.outputs.VERSION }}
          Build Date: ${{ steps.setup.outputs.TIMESTAMP }}
          Commit: ${{ github.sha }}
          Runner OS: ${{ runner.os }}
          
          ================================
          Build Contents
          ================================
          "@ | Out-File -FilePath $manifestPath -Encoding UTF8
          
          Get-ChildItem -Path $distPath -Recurse -File | ForEach-Object {
            $relativePath = $_.FullName.Substring($distPath.Length + 1)
            $size = "{0:N0}" -f $_.Length
            "$relativePath ($size bytes)" | Out-File -FilePath $manifestPath -Append -Encoding UTF8
          }
          
          # Generate DLL dependency report
          $dllReport = "$distPath/DLL_DEPENDENCIES.txt"
          @"
          ================================
          DLL Dependencies Report
          ================================
          Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
          
          "@ | Out-File -FilePath $dllReport -Encoding UTF8
          
          Get-ChildItem -Path $distPath -Filter "*.dll" | ForEach-Object {
            $_.Name | Out-File -FilePath $dllReport -Append -Encoding UTF8
          }
          
          $dllCount = (Get-ChildItem -Path $distPath -Filter "*.dll").Count
          "`nTotal DLLs: $dllCount" | Out-File -FilePath $dllReport -Append -Encoding UTF8
      
      - name: Create Portable ZIP
        shell: pwsh
        run: |
          $zipName = "summit_hip_numbers_${{ matrix.variant }}_portable_${{ steps.setup.outputs.VERSION }}.zip"
          
          # Check if the build script created a zip in dist folder
          $distZip = "dist/${{ matrix.variant }}/summit_hip_numbers_${{ matrix.variant }}_portable.zip"
          if (Test-Path $distZip) {
            Move-Item -Path $distZip -Destination $zipName -Force
          } else {
            # Create from dist folder contents
            Compress-Archive -Path "dist/${{ matrix.variant }}/*" -DestinationPath $zipName -Force
          }
          
          # Verify ZIP integrity
          if (Test-Path $zipName) {
            $zipInfo = Get-Item $zipName
            Write-Host "✓ Created: $zipName ($('{0:N2}' -f ($zipInfo.Length / 1MB)) MB)"
          } else {
            Write-Error "Failed to create ZIP archive"
            exit 1
          }
      
      - name: Build Installer (Full Only)
        if: matrix.variant == 'full'
        shell: pwsh
        run: |
          # Download and install Inno Setup
          $innoUrl = "https://files.jrsoftware.org/is/6/innosetup-6.2.2.exe"
          $innoPath = "$env:TEMP\innosetup.exe"
          Invoke-WebRequest -Uri $innoUrl -OutFile $innoPath
          Start-Process -FilePath $innoPath -ArgumentList "/SP- /VERYSILENT /SUPPRESSMSGBOXES /ALLUSERS" -Wait
          
          # Build installer (if installer.iss exists)
          if (Test-Path "scripts/installer.iss") {
            & "C:\Program Files (x86)\Inno Setup 6\iscc.exe" /Q "scripts/installer.iss"
            
            # Rename with version
            $installerOld = "dist/summit_hip_numbers_installer.exe"
            if (Test-Path $installerOld) {
              $installerNew = "summit_hip_numbers_installer_${{ steps.setup.outputs.VERSION }}.exe"
              Move-Item -Path $installerOld -Destination $installerNew -Force
            }
          } else {
            Write-Host "installer.iss not found, skipping installer creation"
          }
      
      - name: Upload Portable Artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-${{ matrix.variant }}-portable-${{ steps.setup.outputs.VERSION }}
          path: summit_hip_numbers_${{ matrix.variant }}_portable_${{ steps.setup.outputs.VERSION }}.zip
          retention-days: 30
      
      - name: Upload Installer Artifact
        if: matrix.variant == 'full'
        uses: actions/upload-artifact@v4
        with:
          name: windows-installer-${{ steps.setup.outputs.VERSION }}
          path: summit_hip_numbers_installer_${{ steps.setup.outputs.VERSION }}.exe
          retention-days: 30

  # ============================================================================
  # LINUX BUILD - Full & Demo Variants
  # ============================================================================
  
  build-linux:
    name: Linux Build (${{ matrix.variant }})
    runs-on: ubuntu-latest
    needs: validate
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Build Environment
        id: setup
        run: |
          VERSION=$(if [[ $GITHUB_REF == refs/tags/v* ]]; then echo ${GITHUB_REF#refs/tags/v}; else echo "dev-$(git rev-parse --short HEAD)"; fi)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"
      
      - name: Cache Nix Store
        uses: nix-community/cache-nix-action@v6
        with:
          primary-key: nix-${{ runner.os }}-${{ hashFiles('flake.lock') }}-${{ matrix.variant }}
          purge-primary-key: nix-${{ runner.os }}-
          purge-last-accessed: 7d
      
      - name: Install Nix
        uses: cachix/install-nix-action@v25
        with:
          nix_path: nixpkgs=channel:nixos-unstable
      
      - name: Build with Nix
        run: |
          if [ "${{ matrix.variant }}" = "demo" ]; then
            nix build .#demo --print-build-logs
          else
            nix build . --print-build-logs
          fi
      
      - name: Create Portable Distribution
        run: |
          DIST_DIR="dist/linux-${{ matrix.variant }}"
          mkdir -p "$DIST_DIR"
          
          # Copy build result
          cp -rL result/* "$DIST_DIR/"
          
          # Generate manifest
          cat > "$DIST_DIR/BUILD_MANIFEST.txt" << EOF
          ================================
          Summit HIP Numbers - Linux Build
          ================================
          Variant: ${{ matrix.variant }}
          Version: ${{ steps.setup.outputs.VERSION }}
          Build Date: ${{ steps.setup.outputs.TIMESTAMP }}
          Commit: ${{ github.sha }}
          Builder: Nix
          
          ================================
          Build Contents
          ================================
          EOF
          
          find "$DIST_DIR" -type f -exec sh -c 'echo "$(basename {}) ($(stat -f%z {} 2>/dev/null || stat -c%s {}) bytes)"' \; >> "$DIST_DIR/BUILD_MANIFEST.txt"
          
          # Check library dependencies
          if [ -f "$DIST_DIR/bin/summit_hip_numbers" ]; then
            echo -e "\n================================\nLibrary Dependencies\n================================" >> "$DIST_DIR/BUILD_MANIFEST.txt"
            ldd "$DIST_DIR/bin/summit_hip_numbers" >> "$DIST_DIR/BUILD_MANIFEST.txt" || true
          fi
      
      - name: Create Archive
        run: |
          cd dist
          tar -czf "../summit_hip_numbers_linux_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.tar.gz" "linux-${{ matrix.variant }}"
          cd ..
          
          # Also create zip for consistency
          zip -r "summit_hip_numbers_linux_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.zip" "dist/linux-${{ matrix.variant }}"
      
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-${{ matrix.variant }}-${{ steps.setup.outputs.VERSION }}
          path: |
            summit_hip_numbers_linux_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.tar.gz
            summit_hip_numbers_linux_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.zip
          retention-days: 30

  # ============================================================================
  # MACOS BUILD - Full & Demo Variants
  # ============================================================================
  
  build-macos:
    name: macOS Build (${{ matrix.variant }})
    runs-on: macos-latest
    needs: validate
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Build Environment
        id: setup
        run: |
          VERSION=$(if [[ $GITHUB_REF == refs/tags/v* ]]; then echo ${GITHUB_REF#refs/tags/v}; else echo "dev-$(git rev-parse --short HEAD)"; fi)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"
      
      - name: Install Dependencies
        run: |
          chmod +x scripts/install_macos.sh
          ./scripts/install_macos.sh --skip-build
      
      - name: Build Application
        run: |
          chmod +x scripts/build_macos.sh
          ./scripts/build_macos.sh ${{ matrix.variant }}
      
      - name: Create Portable Distribution
        run: |
          FINAL_DIST_DIR="dist/macos-final-${{ matrix.variant }}"
          mkdir -p "$FINAL_DIST_DIR"
          
          # Copy .app bundle - build script creates it in dist/macos-$variant/
          BUILD_DIST="dist/macos-${{ matrix.variant }}"
          if [ -d "$BUILD_DIST/Summit HIP Numbers.app" ]; then
            cp -R "$BUILD_DIST/Summit HIP Numbers.app" "$FINAL_DIST_DIR/"
          elif [ -d "$BUILD_DIST/Summit HIP Numbers Demo.app" ]; then
            cp -R "$BUILD_DIST/Summit HIP Numbers Demo.app" "$FINAL_DIST_DIR/"
          else
            echo "Looking for .app bundles..."
            find dist -name "*.app" -type d
            echo "Error: No .app bundle found in $BUILD_DIST"
            ls -la "$BUILD_DIST" || echo "Build directory does not exist"
            exit 1
          fi
          
          # Generate manifest
          cat > "$FINAL_DIST_DIR/BUILD_MANIFEST.txt" << EOF
          ================================
          Summit HIP Numbers - macOS Build
          ================================
          Variant: ${{ matrix.variant }}
          Version: ${{ steps.setup.outputs.VERSION }}
          Build Date: ${{ steps.setup.outputs.TIMESTAMP }}
          Commit: ${{ github.sha }}
          Architecture: $(uname -m)
          
          ================================
          Build Contents
          ================================
          EOF
          
          find "$FINAL_DIST_DIR" -type f | while read file; do
            echo "$(basename "$file") ($(stat -f%z "$file") bytes)"
          done >> "$FINAL_DIST_DIR/BUILD_MANIFEST.txt"
          
          # Check library dependencies
          APP_PATH=$(find "$FINAL_DIST_DIR" -name "*.app" -type d | head -n 1)
          if [ -n "$APP_PATH" ]; then
            BINARY=$(find "$APP_PATH/Contents/MacOS" -type f -perm +111 | head -n 1)
            if [ -n "$BINARY" ]; then
              echo -e "\n================================\nLibrary Dependencies\n================================" >> "$FINAL_DIST_DIR/BUILD_MANIFEST.txt"
              otool -L "$BINARY" >> "$FINAL_DIST_DIR/BUILD_MANIFEST.txt" || true
            fi
          fi
      
      - name: Create Archives
        run: |
          cd dist
          
          # Create DMG (if available from build)
          if [ -f "macos-${{ matrix.variant }}/*.dmg" ]; then
            cp "macos-${{ matrix.variant }}/*.dmg" "../summit_hip_numbers_macos_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.dmg"
          fi
          
          # Create ZIP of .app bundle from final distribution
          zip -r "../summit_hip_numbers_macos_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.zip" "macos-final-${{ matrix.variant }}"
          
          cd ..
      
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-${{ matrix.variant }}-${{ steps.setup.outputs.VERSION }}
          path: |
            summit_hip_numbers_macos_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.dmg
            summit_hip_numbers_macos_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.zip
          retention-days: 30
          if-no-files-found: warn

  # ============================================================================
  # COMPREHENSIVE TESTING
  # ============================================================================
  
  test-windows-portable:
    name: Test Windows Portable (${{ matrix.variant }})
    runs-on: windows-latest
    needs: build-windows
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          pattern: windows-${{ matrix.variant }}-portable-*
          merge-multiple: true
      
      - name: Comprehensive Portable Test
        shell: pwsh
        run: |
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  WINDOWS PORTABLE TEST - ${{ matrix.variant }}" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan
          
          # Find and extract ZIP
          $zipFile = Get-ChildItem -Filter "summit_hip_numbers_${{ matrix.variant }}_portable_*.zip" | Select-Object -First 1
          if (-not $zipFile) {
            Write-Error "Portable ZIP not found"
            exit 1
          }
          
          Write-Host "`n[1/6] Extracting archive: $($zipFile.Name)" -ForegroundColor Yellow
          Expand-Archive -Path $zipFile.FullName -DestinationPath "test_portable" -Force
          
          # Test structure
          Write-Host "`n[2/6] Validating directory structure..." -ForegroundColor Yellow
          $structure = Get-ChildItem -Path "test_portable" -Recurse | Select-Object FullName, Length, @{N='Type';E={if($_.PSIsContainer){'DIR'}else{'FILE'}}}
          $structure | Format-Table -AutoSize | Out-String | Write-Host
          
          # Find executable
          Write-Host "`n[3/6] Locating executable..." -ForegroundColor Yellow
          $exeName = if ("${{ matrix.variant }}" -eq "demo") { "summit_hip_numbers_demo.exe" } else { "summit_hip_numbers.exe" }
          $exePath = Get-ChildItem -Path "test_portable" -Filter $exeName -Recurse -File | Select-Object -First 1
          
          if (-not $exePath) {
            Write-Error "Executable $exeName not found"
            exit 1
          }
          Write-Host "  ✓ Found: $($exePath.FullName)" -ForegroundColor Green
          
          # Verify critical DLLs
          Write-Host "`n[4/6] Verifying critical DLLs..." -ForegroundColor Yellow
          $criticalDlls = @(
            "libglib-2.0-0.dll",
            "libgobject-2.0-0.dll",
            "libgio-2.0-0.dll",
            "libgstreamer-1.0-0.dll",
            "libgstapp-1.0-0.dll",
            "libgstbase-1.0-0.dll",
            "libgstvideo-1.0-0.dll",
            "libgstaudio-1.0-0.dll"
          )
          
          $workingDir = Split-Path -Parent $exePath.FullName
          $missingDlls = @()
          
          foreach ($dll in $criticalDlls) {
            $dllPath = Join-Path $workingDir $dll
            if (Test-Path $dllPath) {
              $dllSize = (Get-Item $dllPath).Length
              Write-Host "  ✓ $dll ($([math]::Round($dllSize/1KB, 2)) KB)" -ForegroundColor Green
            } else {
              Write-Host "  ✗ $dll MISSING" -ForegroundColor Red
              $missingDlls += $dll
            }
          }
          
          if ($missingDlls.Count -gt 0) {
            Write-Error "Missing critical DLLs: $($missingDlls -join ', ')"
            Write-Host "`nAvailable DLLs in directory:" -ForegroundColor Yellow
            Get-ChildItem -Path $workingDir -Filter "*.dll" | ForEach-Object { Write-Host "  - $($_.Name)" }
            exit 1
          }
          
          # Check GStreamer plugins
          Write-Host "`n[5/6] Checking GStreamer plugins..." -ForegroundColor Yellow
          $pluginDirs = @(
            (Join-Path $workingDir "lib\gstreamer-1.0"),
            (Join-Path $workingDir "gstreamer-1.0")
          )
          
          $foundPlugins = $false
          foreach ($pluginDir in $pluginDirs) {
            if (Test-Path $pluginDir) {
              $plugins = Get-ChildItem -Path $pluginDir -Filter "*.dll"
              Write-Host "  ✓ Found $($plugins.Count) plugins in: $pluginDir" -ForegroundColor Green
              $foundPlugins = $true
              break
            }
          }
          
          if (-not $foundPlugins) {
            Write-Warning "No GStreamer plugins found - audio/video may not work"
          }
          
          # Runtime test
          Write-Host "`n[6/6] Runtime execution test..." -ForegroundColor Yellow
          $logFile = Join-Path $workingDir "test-execution.log"
          $errorLog = Join-Path $workingDir "test-execution-error.log"
          
          try {
            $process = Start-Process -FilePath $exePath.FullName `
                                    -WorkingDirectory $workingDir `
                                    -PassThru `
                                    -NoNewWindow `
                                    -RedirectStandardOutput $logFile `
                                    -RedirectStandardError $errorLog
            
            Write-Host "  Process started (PID: $($process.Id))" -ForegroundColor Green
            
            # Wait and monitor
            Start-Sleep -Seconds 3
            
            if ($process.HasExited) {
              Write-Error "Process exited prematurely with code: $($process.ExitCode)"
              Get-Content $errorLog | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
              exit 1
            }
            
            Write-Host "  ✓ Process running successfully" -ForegroundColor Green
            
            # Simulate interaction
            Write-Host "  Simulating user interaction..." -ForegroundColor Yellow
            Add-Type -AssemblyName System.Windows.Forms
            Start-Sleep -Seconds 1
            [System.Windows.Forms.SendKeys]::SendWait("{DOWN}")
            Start-Sleep -Seconds 1
            [System.Windows.Forms.SendKeys]::SendWait("{UP}")
            Start-Sleep -Seconds 2
            
            # Check if still running
            if (Get-Process -Id $process.Id -ErrorAction SilentlyContinue) {
              Write-Host "  ✓ Process stable after interaction" -ForegroundColor Green
              Stop-Process -Id $process.Id -Force
            } else {
              Write-Warning "Process exited during interaction test"
            }
            
          } catch {
            Write-Error "Runtime test failed: $_"
            if (Test-Path $errorLog) {
              Get-Content $errorLog
            }
            exit 1
          }
          
          # Display logs
          Write-Host "`n============================================" -ForegroundColor Cyan
          Write-Host "  EXECUTION LOGS" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan
          if (Test-Path $logFile) {
            Get-Content $logFile | Write-Host
          }
          if (Test-Path $errorLog) {
            Write-Host "`nError Log:" -ForegroundColor Yellow
            Get-Content $errorLog | Write-Host
          }
          
          Write-Host "`n============================================" -ForegroundColor Green
          Write-Host "  ✓ ALL TESTS PASSED" -ForegroundColor Green
          Write-Host "============================================" -ForegroundColor Green
      
      - name: Upload Test Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: windows-${{ matrix.variant }}-test-logs
          path: test_portable/**/*.log
          retention-days: 7

  test-linux-portable:
    name: Test Linux Portable (${{ matrix.variant }})
    runs-on: ubuntu-latest
    needs: build-linux
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          pattern: linux-${{ matrix.variant }}-*
          merge-multiple: true
      
      - name: Comprehensive Linux Test
        run: |
          echo "============================================"
          echo "  LINUX PORTABLE TEST - ${{ matrix.variant }}"
          echo "============================================"
          
          # Extract archive
          echo -e "\n[1/5] Extracting archive..."
          ARCHIVE=$(ls summit_hip_numbers_linux_${{ matrix.variant }}_*.tar.gz | head -n 1)
          if [ -z "$ARCHIVE" ]; then
            echo "ERROR: Archive not found"
            exit 1
          fi
          tar -xzf "$ARCHIVE"
          
          # Validate structure
          echo -e "\n[2/5] Validating structure..."
          find dist/linux-${{ matrix.variant }} -type f -exec ls -lh {} \;
          
          # Find binary
          echo -e "\n[3/5] Locating binary..."
          BINARY=$(find dist/linux-${{ matrix.variant }} -name "summit_hip_numbers*" -type f -executable | head -n 1)
          if [ -z "$BINARY" ]; then
            echo "ERROR: Binary not found"
            exit 1
          fi
          echo "✓ Found: $BINARY"
          
          # Check dependencies
          echo -e "\n[4/5] Checking library dependencies..."
          ldd "$BINARY" || echo "Note: ldd failed (may be statically linked)"
          
          # Quick runtime test
          echo -e "\n[5/5] Runtime test..."
          timeout 5s "$BINARY" --version || echo "✓ Binary executed (timed out as expected)"
          
          echo -e "\n============================================"
          echo "  ✓ ALL TESTS PASSED"
          echo "============================================"

  # ============================================================================
  # BUILD SUMMARY & RELEASE
  # ============================================================================
  
  build-summary:
    name: Build Summary Report
    runs-on: ubuntu-latest
    needs: [test-windows-portable, test-linux-portable, build-macos]
    if: always()
    
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts
      
      - name: Generate Build Summary
        run: |
          cat > BUILD_SUMMARY.md << 'EOF'
          # Summit HIP Numbers - Build Summary
          
          **Build Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Commit:** ${{ github.sha }}
          **Branch:** ${{ github.ref_name }}
          
          ## Build Artifacts
          
          EOF
          
          echo "### Windows Builds" >> BUILD_SUMMARY.md
          find all-artifacts -name "*windows*" -type f | while read file; do
            SIZE=$(du -h "$file" | cut -f1)
            echo "- $(basename "$file") ($SIZE)" >> BUILD_SUMMARY.md
          done
          
          echo -e "\n### Linux Builds" >> BUILD_SUMMARY.md
          find all-artifacts -name "*linux*" -type f | while read file; do
            SIZE=$(du -h "$file" | cut -f1)
            echo "- $(basename "$file") ($SIZE)" >> BUILD_SUMMARY.md
          done
          
          echo -e "\n### macOS Builds" >> BUILD_SUMMARY.md
          find all-artifacts -name "*macos*" -type f | while read file; do
            SIZE=$(du -h "$file" | cut -f1)
            echo "- $(basename "$file") ($SIZE)" >> BUILD_SUMMARY.md
          done
          
          cat BUILD_SUMMARY.md
      
      - name: Upload Summary
        uses: actions/upload-artifact@v4
        with:
          name: build-summary
          path: BUILD_SUMMARY.md

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [test-windows-portable, test-linux-portable, build-macos]
    if: github.event_name == 'release'
    permissions:
      contents: write
    
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Prepare Release Files
        run: |
          mkdir -p release_files
          
          # Copy all distribution archives
          find artifacts -name "*.zip" -exec cp {} release_files/ \;
          find artifacts -name "*.tar.gz" -exec cp {} release_files/ \;
          find artifacts -name "*.dmg" -exec cp {} release_files/ \;
          find artifacts -name "*.exe" -exec cp {} release_files/ \;
          
          # List release files
          echo "Release files:"
          ls -lh release_files/
      
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: release_files/*
          token: ${{ secrets.GITHUB_TOKEN }}
          generate_release_notes: true
          fail_on_unmatched_files: true