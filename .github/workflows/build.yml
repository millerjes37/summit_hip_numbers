name: Comprehensive Build & Test Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  release:
    types: [published]

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: full
  RUST_LOG: debug

jobs:
  # ============================================================================
  # PRE-BUILD VALIDATION
  # ============================================================================
  
  validate:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgstreamer1.0-dev \
            libgstreamer-plugins-base1.0-dev \
            libglib2.0-dev \
            libgtk-3-dev \
            pkg-config
      
      - uses: dtolnay/rust-toolchain@stable
      
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "crates/summit_hip_numbers"
          cache-on-failure: true
      
      - name: Format Check
        run: cargo fmt --all -- --check
      
      - name: Clippy (All Targets)
        run: cargo clippy --all-targets --all-features -- -D warnings
      
      - name: Unit Tests
        run: cargo test --workspace --verbose
      
      - name: Security Audit
        run: |
          cargo install cargo-audit
          cargo audit
      
      - name: Dependency Check
        run: cargo tree --duplicates

  # ============================================================================
  # WINDOWS BUILD - Full & Demo Variants
  # ============================================================================
  
  build-windows:
    name: Windows Build (${{ matrix.variant }})
    runs-on: windows-latest
    needs: validate
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
      
      - name: Setup Build Environment
        id: setup
        shell: pwsh
        run: |
          # Set version from Cargo.toml or git tag
          $version = if ($env:GITHUB_REF -match 'refs/tags/v(.*)') { 
            $matches[1] 
          } else { 
            "dev-$(git rev-parse --short HEAD)" 
          }
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "Building version: $version"
          
          # Create build timestamp
          $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          echo "TIMESTAMP=$timestamp" >> $env:GITHUB_OUTPUT
      
      - name: Cache Cargo Registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-
      
      - name: Setup MSYS2 & GStreamer
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          install: >-
            mingw-w64-x86_64-toolchain
            mingw-w64-x86_64-pkg-config
            mingw-w64-x86_64-glib2
            mingw-w64-x86_64-gstreamer
            mingw-w64-x86_64-gst-plugins-base
            mingw-w64-x86_64-gst-plugins-good
            mingw-w64-x86_64-gst-plugins-bad
            mingw-w64-x86_64-gst-plugins-ugly
            mingw-w64-x86_64-gst-libav
            mingw-w64-x86_64-libxml2
            mingw-w64-x86_64-xz
            mingw-w64-x86_64-bzip2
            mingw-w64-x86_64-freetype
            mingw-w64-x86_64-harfbuzz
            mingw-w64-x86_64-libpng
            mingw-w64-x86_64-orc
            zip
            unzip
          update: true
          path-type: inherit
      
      - name: Verify System Dependencies
        shell: msys2 {0}
        run: |
          set +e  # Don't exit on error
          echo "============================================"
          echo "  VERIFYING SYSTEM DEPENDENCIES"
          echo "============================================"
          
          # Check what's actually installed
          echo "Checking /mingw64/bin for relevant DLLs..."
          ls -la /mingw64/bin/libxml2*.dll 2>/dev/null || echo "  No libxml2 DLL variants found"
          ls -la /mingw64/bin/liblzma*.dll 2>/dev/null || echo "  No liblzma DLL variants found"
          
          # Verify system DLLs are present
          SYSTEM_DLLS=(
            "liblzma-5.dll"
            "libbz2-1.dll"
            "libfreetype-6.dll"
            "libharfbuzz-0.dll"
            "libpng16-16.dll"
            "liborc-0.4-0.dll"
          )
          
          MISSING_COUNT=0
          for dll in "${SYSTEM_DLLS[@]}"; do
            if [ -f "/mingw64/bin/$dll" ]; then
              echo "  ✓ $dll found"
            else
              echo "  ✗ $dll NOT FOUND"
              MISSING_COUNT=$((MISSING_COUNT + 1))
            fi
          done
          
          # Check for libxml2 separately since it may have different versions
          if [ -f "/mingw64/bin/libxml2-2.dll" ]; then
            echo "  ✓ libxml2-2.dll found"
          elif [ -f "/mingw64/bin/libxml2.dll" ]; then
            echo "  ✓ libxml2.dll found (alternative version)"
          else
            echo "  ⚠ libxml2 NOT FOUND (optional - needed for some media formats)"
            MISSING_COUNT=$((MISSING_COUNT + 1))
          fi
          
          if [ $MISSING_COUNT -gt 0 ]; then
            echo ""
            echo "  ⚠ Warning: $MISSING_COUNT system DLLs not found"
            echo "  These are optional but recommended for full functionality"
            echo "  Build will continue - missing DLLs will be skipped"
          else
            echo ""
            echo "  ✓ All system dependencies found"
          fi
          
          echo "============================================"
          
          # Always exit successfully - these are optional dependencies
          exit 0
      
      - name: Setup Rust GNU Toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable-x86_64-pc-windows-gnu
      
      - name: Comprehensive GStreamer Verification
        shell: msys2 {0}
        run: |
          echo "============================================"
          echo "  COMPREHENSIVE GSTREAMER VERIFICATION"
          echo "============================================"
          
          # Set up environment
          export MSYSTEM=MINGW64
          export MSYSTEM_PREFIX=/mingw64
          export PATH="$MSYSTEM_PREFIX/bin:$PATH"
          export PKG_CONFIG_PATH="/mingw64/lib/pkgconfig:$PKG_CONFIG_PATH"
          
          # Function to check if a command exists
          command_exists() {
            command -v "$1" >/dev/null 2>&1
          }
          
          # Function to check if a file exists
          file_exists() {
            test -f "$1"
          }
          
          # Function to check if a directory exists
          dir_exists() {
            test -d "$1"
          }
          
          echo "1. Checking GStreamer executables..."
          GSTREAMER_TOOLS=(
            "gst-inspect-1.0"
            "gst-launch-1.0"
            "gst-discoverer-1.0"
            "gst-typefind-1.0"
          )
          
          for tool in "${GSTREAMER_TOOLS[@]}"; do
            if command_exists "$tool"; then
              echo "  ✓ $tool: $(which $tool)"
            else
              echo "  ✗ $tool: NOT FOUND"
              exit 1
            fi
          done
          
          echo -e "\n2. Checking core GStreamer libraries..."
          CORE_LIBS=(
            "/mingw64/lib/libgstreamer-1.0.dll.a"
            "/mingw64/lib/libgstbase-1.0.dll.a"
            "/mingw64/lib/libgstapp-1.0.dll.a"
            "/mingw64/lib/libgstvideo-1.0.dll.a"
            "/mingw64/lib/libgstaudio-1.0.dll.a"
          )
          
          for lib in "${CORE_LIBS[@]}"; do
            if file_exists "$lib"; then
              echo "  ✓ $(basename $lib): $(ls -lh $lib | awk '{print $5}')"
            else
              echo "  ✗ $(basename $lib): NOT FOUND"
              exit 1
            fi
          done
          
          echo -e "\n3. Checking runtime DLLs..."
          RUNTIME_DLLS=(
            "/mingw64/bin/libgstreamer-1.0-0.dll"
            "/mingw64/bin/libgstbase-1.0-0.dll"
            "/mingw64/bin/libgstapp-1.0-0.dll"
            "/mingw64/bin/libgstvideo-1.0-0.dll"
            "/mingw64/bin/libgstaudio-1.0-0.dll"
            "/mingw64/bin/libglib-2.0-0.dll"
            "/mingw64/bin/libgobject-2.0-0.dll"
            "/mingw64/bin/libgio-2.0-0.dll"
          )
          
          for dll in "${RUNTIME_DLLS[@]}"; do
            if file_exists "$dll"; then
              echo "  ✓ $(basename $dll): $(ls -lh $dll | awk '{print $5}')"
            else
              echo "  ✗ $(basename $dll): NOT FOUND"
              exit 1
            fi
          done
          
          echo -e "\n4. Checking GStreamer plugin directories..."
          PLUGIN_DIRS=(
            "/mingw64/lib/gstreamer-1.0"
            "/mingw64/bin/gstreamer-1.0"
          )
          
          for plugin_dir in "${PLUGIN_DIRS[@]}"; do
            if dir_exists "$plugin_dir"; then
              plugin_count=$(find "$plugin_dir" -name "*.dll" | wc -l)
              echo "  ✓ $plugin_dir: $plugin_count plugins"
              if [ $plugin_count -lt 10 ]; then
                echo "    WARNING: Low plugin count, checking specific plugins..."
              fi
            else
              echo "  ✗ $plugin_dir: NOT FOUND"
            fi
          done
          
          echo -e "\n5. Verifying essential plugins..."
          ESSENTIAL_PLUGINS=(
            "coreelements"
            "playback"
            "typefindfunctions"
            "app"
            "videoconvert"
            "videoscale"
            "autodetect"
          )
          
          OPTIONAL_PLUGINS=(
            "directsound"
            "wasapi"
          )
          
          missing_essential=0
          for plugin in "${ESSENTIAL_PLUGINS[@]}"; do
            if gst-inspect-1.0 "$plugin" >/dev/null 2>&1; then
              echo "  ✓ $plugin"
            else
              echo "  ✗ $plugin: NOT AVAILABLE"
              ((missing_essential++))
            fi
          done
          
          for plugin in "${OPTIONAL_PLUGINS[@]}"; do
            if gst-inspect-1.0 "$plugin" >/dev/null 2>&1; then
              echo "  ✓ $plugin (optional)"
            else
              echo "  ⚠ $plugin: NOT AVAILABLE (optional)"
            fi
          done
          
          if [ $missing_essential -gt 3 ]; then
            echo "  ✗ Too many essential plugins missing ($missing_essential)"
            exit 1
          fi
          
          echo -e "\n6. Testing pkg-config integration..."
          if pkg-config --exists gstreamer-1.0; then
            GST_VERSION=$(pkg-config --modversion gstreamer-1.0)
            GST_CFLAGS=$(pkg-config --cflags gstreamer-1.0)
            GST_LIBS=$(pkg-config --libs gstreamer-1.0)
            echo "  ✓ GStreamer version: $GST_VERSION"
            echo "  ✓ CFLAGS: $GST_CFLAGS"
            echo "  ✓ LIBS: $GST_LIBS"
          else
            echo "  ✗ pkg-config cannot find gstreamer-1.0"
            exit 1
          fi
          
          echo -e "\n7. Testing basic GStreamer functionality..."
          if timeout 10s bash -c 'echo "videotestsrc num-buffers=1 ! fakesink" | gst-launch-1.0 >/dev/null 2>&1'; then
            echo "  ✓ Basic pipeline test passed"
          else
            echo "  ⚠ Basic pipeline test failed (but continuing)"
          fi
          
          echo -e "\n8. Environment summary..."
          echo "  PATH: $PATH"
          echo "  PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
          echo "  MSYSTEM: $MSYSTEM"
          echo "  MSYSTEM_PREFIX: $MSYSTEM_PREFIX"
          
          echo -e "\n============================================"
          echo "  ✅ ALL GSTREAMER CHECKS PASSED"
          echo "============================================"
      
      - name: Use Complete Build Script
        shell: msys2 {0}
        run: |
          # Make the complete build script executable
          chmod +x scripts/build_windows_complete.sh
      
      - name: Execute Complete Windows Build
        shell: msys2 {0}
        run: |
          # Run the complete build script
          ./scripts/build_windows_complete.sh ${{ matrix.variant }}
          
          # Display build logs
          echo "============================================"
          echo "  BUILD LOG SUMMARY"
          echo "============================================"
          
          if [ -f "build_${{ matrix.variant }}_*.log" ]; then
            latest_log=$(ls -t build_${{ matrix.variant }}_*.log | head -n1)
            echo "Latest build log: $latest_log"
            tail -30 "$latest_log"
          fi
          
          if [ -f "build_${{ matrix.variant }}_errors.log" ]; then
            echo -e "\nERROR LOG:"
            cat "build_${{ matrix.variant }}_errors.log"
          fi
      
      - name: Upload Build Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: windows-${{ matrix.variant }}-build-logs
          path: |
            build_${{ matrix.variant }}_*.log
            build_${{ matrix.variant }}_errors.log
          retention-days: 7
          
      
      - name: Generate Build Manifest
        shell: pwsh
        run: |
          $distPath = "dist/${{ matrix.variant }}"
          $manifestPath = "$distPath/BUILD_MANIFEST.txt"
          
          @"
          ================================
          Summit HIP Numbers - Windows Build
          ================================
          Variant: ${{ matrix.variant }}
          Version: ${{ steps.setup.outputs.VERSION }}
          Build Date: ${{ steps.setup.outputs.TIMESTAMP }}
          Commit: ${{ github.sha }}
          Runner OS: ${{ runner.os }}
          
          ================================
          Build Contents
          ================================
          "@ | Out-File -FilePath $manifestPath -Encoding UTF8
          
          Get-ChildItem -Path $distPath -Recurse -File | ForEach-Object {
            $relativePath = $_.FullName.Substring($distPath.Length + 1)
            $size = "{0:N0}" -f $_.Length
            "$relativePath ($size bytes)" | Out-File -FilePath $manifestPath -Append -Encoding UTF8
          }
          
          # Generate DLL dependency report
          $dllReport = "$distPath/DLL_DEPENDENCIES.txt"
          @"
          ================================
          DLL Dependencies Report
          ================================
          Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
          
          "@ | Out-File -FilePath $dllReport -Encoding UTF8
          
          Get-ChildItem -Path $distPath -Filter "*.dll" | ForEach-Object {
            $_.Name | Out-File -FilePath $dllReport -Append -Encoding UTF8
          }
          
          $dllCount = (Get-ChildItem -Path $distPath -Filter "*.dll").Count
          "`nTotal DLLs: $dllCount" | Out-File -FilePath $dllReport -Append -Encoding UTF8
      
      - name: Create Portable ZIP
        shell: pwsh
        run: |
          $zipName = "summit_hip_numbers_${{ matrix.variant }}_portable_${{ steps.setup.outputs.VERSION }}.zip"
          
          # Check if the build script created a zip in dist folder
          $distZip = "dist/${{ matrix.variant }}/summit_hip_numbers_${{ matrix.variant }}_portable.zip"
          if (Test-Path $distZip) {
            Move-Item -Path $distZip -Destination $zipName -Force
          } else {
            # Create from dist folder contents
            Compress-Archive -Path "dist/${{ matrix.variant }}/*" -DestinationPath $zipName -Force
          }
          
          # Verify ZIP integrity
          if (Test-Path $zipName) {
            $zipInfo = Get-Item $zipName
            Write-Host "✓ Created: $zipName ($('{0:N2}' -f ($zipInfo.Length / 1MB)) MB)"
          } else {
            Write-Error "Failed to create ZIP archive"
            exit 1
          }
      
      - name: Build Installer (Full Only)
        if: matrix.variant == 'full'
        shell: pwsh
        run: |
          # Download and install Inno Setup
          $innoUrl = "https://files.jrsoftware.org/is/6/innosetup-6.2.2.exe"
          $innoPath = "$env:TEMP\innosetup.exe"
          Invoke-WebRequest -Uri $innoUrl -OutFile $innoPath
          Start-Process -FilePath $innoPath -ArgumentList "/SP- /VERYSILENT /SUPPRESSMSGBOXES /ALLUSERS" -Wait
          
          # Build installer (if installer.iss exists)
          if (Test-Path "scripts/installer.iss") {
            & "C:\Program Files (x86)\Inno Setup 6\iscc.exe" /Q "scripts/installer.iss"
            
            # Rename with version
            $installerOld = "dist/summit_hip_numbers_installer.exe"
            if (Test-Path $installerOld) {
              $installerNew = "summit_hip_numbers_installer_${{ steps.setup.outputs.VERSION }}.exe"
              Move-Item -Path $installerOld -Destination $installerNew -Force
            }
          } else {
            Write-Host "installer.iss not found, skipping installer creation"
          }
      
      - name: Upload Portable Artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-${{ matrix.variant }}-portable-${{ steps.setup.outputs.VERSION }}
          path: summit_hip_numbers_${{ matrix.variant }}_portable_${{ steps.setup.outputs.VERSION }}.zip
          retention-days: 30
      
      - name: Upload Installer Artifact
        if: matrix.variant == 'full'
        uses: actions/upload-artifact@v4
        with:
          name: windows-installer-${{ steps.setup.outputs.VERSION }}
          path: summit_hip_numbers_installer_${{ steps.setup.outputs.VERSION }}.exe
          retention-days: 30

  # ============================================================================
  # LINUX BUILD - Full & Demo Variants
  # ============================================================================
  
  build-linux:
    name: Linux Build (${{ matrix.variant }})
    runs-on: ubuntu-latest
    needs: validate
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
      
      - name: Setup Build Environment
        id: setup
        run: |
          VERSION=$(if [[ $GITHUB_REF == refs/tags/v* ]]; then echo ${GITHUB_REF#refs/tags/v}; else echo "dev-$(git rev-parse --short HEAD)"; fi)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"
      
      - name: Cache Nix Store
        uses: nix-community/cache-nix-action@v6
        with:
          primary-key: nix-${{ runner.os }}-${{ hashFiles('flake.lock') }}-${{ matrix.variant }}
          purge-primary-key: nix-${{ runner.os }}-
          purge-last-accessed: 7d
      
      - name: Install Nix
        uses: cachix/install-nix-action@v25
        with:
          nix_path: nixpkgs=channel:nixos-unstable
      
      - name: Build with Nix
        run: |
          if [ "${{ matrix.variant }}" = "demo" ]; then
            nix build .#demo --print-build-logs
          else
            nix build . --print-build-logs
          fi
      
      - name: Create Portable Distribution
        run: |
          DIST_DIR="dist/linux-${{ matrix.variant }}"
          mkdir -p "$DIST_DIR"
          
          # Copy build result
          cp -rL result/* "$DIST_DIR/"
          
          # Generate manifest
          cat > "$DIST_DIR/BUILD_MANIFEST.txt" << EOF
          ================================
          Summit HIP Numbers - Linux Build
          ================================
          Variant: ${{ matrix.variant }}
          Version: ${{ steps.setup.outputs.VERSION }}
          Build Date: ${{ steps.setup.outputs.TIMESTAMP }}
          Commit: ${{ github.sha }}
          Builder: Nix
          
          ================================
          Build Contents
          ================================
          EOF
          
          find "$DIST_DIR" -type f -exec sh -c 'echo "$(basename {}) ($(stat -f%z {} 2>/dev/null || stat -c%s {}) bytes)"' \; >> "$DIST_DIR/BUILD_MANIFEST.txt"
          
          # Check library dependencies
          if [ -f "$DIST_DIR/bin/summit_hip_numbers" ]; then
            echo -e "\n================================\nLibrary Dependencies\n================================" >> "$DIST_DIR/BUILD_MANIFEST.txt"
            ldd "$DIST_DIR/bin/summit_hip_numbers" >> "$DIST_DIR/BUILD_MANIFEST.txt" || true
          fi
      
      - name: Create Archive
        run: |
          cd dist
          tar -czf "../summit_hip_numbers_linux_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.tar.gz" "linux-${{ matrix.variant }}"
          cd ..
          
          # Also create zip for consistency
          zip -r "summit_hip_numbers_linux_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.zip" "dist/linux-${{ matrix.variant }}"
      
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-${{ matrix.variant }}-${{ steps.setup.outputs.VERSION }}
          path: |
            summit_hip_numbers_linux_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.tar.gz
            summit_hip_numbers_linux_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.zip
          retention-days: 30

  # ============================================================================
  # MACOS BUILD - Full & Demo Variants
  # ============================================================================
  
  build-macos:
    name: macOS Build (${{ matrix.variant }})
    runs-on: macos-latest
    needs: validate
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
      
      - name: Setup Build Environment
        id: setup
        run: |
          VERSION=$(if [[ $GITHUB_REF == refs/tags/v* ]]; then echo ${GITHUB_REF#refs/tags/v}; else echo "dev-$(git rev-parse --short HEAD)"; fi)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"
      
      - name: Install Dependencies
        run: |
          chmod +x scripts/install_macos.sh
          ./scripts/install_macos.sh --skip-build
      
      - name: Build Application
        run: |
          chmod +x scripts/build_macos.sh
          ./scripts/build_macos.sh ${{ matrix.variant }}
      
      - name: Create Portable Distribution
        run: |
          FINAL_DIST_DIR="dist/macos-final-${{ matrix.variant }}"
          mkdir -p "$FINAL_DIST_DIR"
          
          # Copy .app bundle - build script creates it in dist/macos-$variant/
          BUILD_DIST="dist/macos-${{ matrix.variant }}"
          if [ -d "$BUILD_DIST/Summit HIP Numbers.app" ]; then
            cp -R "$BUILD_DIST/Summit HIP Numbers.app" "$FINAL_DIST_DIR/"
          elif [ -d "$BUILD_DIST/Summit HIP Numbers Demo.app" ]; then
            cp -R "$BUILD_DIST/Summit HIP Numbers Demo.app" "$FINAL_DIST_DIR/"
          else
            echo "Looking for .app bundles..."
            find dist -name "*.app" -type d
            echo "Error: No .app bundle found in $BUILD_DIST"
            ls -la "$BUILD_DIST" || echo "Build directory does not exist"
            exit 1
          fi
          
          # Generate manifest
          cat > "$FINAL_DIST_DIR/BUILD_MANIFEST.txt" << EOF
          ================================
          Summit HIP Numbers - macOS Build
          ================================
          Variant: ${{ matrix.variant }}
          Version: ${{ steps.setup.outputs.VERSION }}
          Build Date: ${{ steps.setup.outputs.TIMESTAMP }}
          Commit: ${{ github.sha }}
          Architecture: $(uname -m)
          
          ================================
          Build Contents
          ================================
          EOF
          
          find "$FINAL_DIST_DIR" -type f | while read file; do
            echo "$(basename "$file") ($(stat -f%z "$file") bytes)"
          done >> "$FINAL_DIST_DIR/BUILD_MANIFEST.txt"
          
          # Check library dependencies
          APP_PATH=$(find "$FINAL_DIST_DIR" -name "*.app" -type d | head -n 1)
          if [ -n "$APP_PATH" ]; then
            BINARY=$(find "$APP_PATH/Contents/MacOS" -type f -perm +111 | head -n 1)
            if [ -n "$BINARY" ]; then
              echo -e "\n================================\nLibrary Dependencies\n================================" >> "$FINAL_DIST_DIR/BUILD_MANIFEST.txt"
              otool -L "$BINARY" >> "$FINAL_DIST_DIR/BUILD_MANIFEST.txt" || true
            fi
          fi
      
      - name: Create Archives
        run: |
          cd dist
          
          # Create DMG (if available from build)
          if [ -f "macos-${{ matrix.variant }}/*.dmg" ]; then
            cp "macos-${{ matrix.variant }}/*.dmg" "../summit_hip_numbers_macos_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.dmg"
          fi
          
          # Create ZIP of .app bundle from final distribution
          zip -r "../summit_hip_numbers_macos_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.zip" "macos-final-${{ matrix.variant }}"
          
          cd ..
      
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-${{ matrix.variant }}-${{ steps.setup.outputs.VERSION }}
          path: |
            summit_hip_numbers_macos_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.dmg
            summit_hip_numbers_macos_${{ matrix.variant }}_${{ steps.setup.outputs.VERSION }}.zip
          retention-days: 30
          if-no-files-found: warn

  # ============================================================================
  # COMPREHENSIVE TESTING
  # ============================================================================
  
  test-windows-portable:
    name: Test Windows Portable (${{ matrix.variant }})
    runs-on: windows-latest
    needs: build-windows
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          pattern: windows-${{ matrix.variant }}-portable-*
          merge-multiple: true
      
      - name: Comprehensive Portable Test
        shell: pwsh
        run: |
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  WINDOWS PORTABLE TEST - ${{ matrix.variant }}" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan
          
          # Find and extract ZIP
          $zipFile = Get-ChildItem -Filter "summit_hip_numbers_${{ matrix.variant }}_portable_*.zip" | Select-Object -First 1
          if (-not $zipFile) {
            Write-Error "Portable ZIP not found"
            exit 1
          }
          
          Write-Host "`n[1/6] Extracting archive: $($zipFile.Name)" -ForegroundColor Yellow
          Expand-Archive -Path $zipFile.FullName -DestinationPath "test_portable" -Force
          
          # Test structure
          Write-Host "`n[2/6] Validating directory structure..." -ForegroundColor Yellow
          $structure = Get-ChildItem -Path "test_portable" -Recurse | Select-Object FullName, Length, @{N='Type';E={if($_.PSIsContainer){'DIR'}else{'FILE'}}}
          $structure | Format-Table -AutoSize | Out-String | Write-Host
          
          # Find executable
          Write-Host "`n[3/6] Locating executable..." -ForegroundColor Yellow
          $exeName = if ("${{ matrix.variant }}" -eq "demo") { "summit_hip_numbers_demo.exe" } else { "summit_hip_numbers.exe" }
          $exePath = Get-ChildItem -Path "test_portable" -Filter $exeName -Recurse -File | Select-Object -First 1
          
          if (-not $exePath) {
            Write-Error "Executable $exeName not found"
            exit 1
          }
          Write-Host "  ✓ Found: $($exePath.FullName)" -ForegroundColor Green
          
          # Verify critical DLLs
          Write-Host "`n[4/6] Verifying critical DLLs..." -ForegroundColor Yellow
          $criticalDlls = @(
            "libglib-2.0-0.dll",
            "libgobject-2.0-0.dll",
            "libgio-2.0-0.dll",
            "libgstreamer-1.0-0.dll",
            "libgstapp-1.0-0.dll",
            "libgstbase-1.0-0.dll",
            "libgstvideo-1.0-0.dll",
            "libgstaudio-1.0-0.dll"
          )
          
          $workingDir = Split-Path -Parent $exePath.FullName
          $missingDlls = @()
          
          foreach ($dll in $criticalDlls) {
            $dllPath = Join-Path $workingDir $dll
            if (Test-Path $dllPath) {
              $dllSize = (Get-Item $dllPath).Length
              Write-Host "  ✓ $dll ($([math]::Round($dllSize/1KB, 2)) KB)" -ForegroundColor Green
            } else {
              Write-Host "  ✗ $dll MISSING" -ForegroundColor Red
              $missingDlls += $dll
            }
          }
          
          if ($missingDlls.Count -gt 0) {
            Write-Error "Missing critical DLLs: $($missingDlls -join ', ')"
            Write-Host "`nAvailable DLLs in directory:" -ForegroundColor Yellow
            Get-ChildItem -Path $workingDir -Filter "*.dll" | ForEach-Object { Write-Host "  - $($_.Name)" }
            exit 1
          }
          
          # Check GStreamer plugins
          Write-Host "`n[5/6] Checking GStreamer plugins..." -ForegroundColor Yellow
          $pluginDirs = @(
            (Join-Path $workingDir "lib\gstreamer-1.0"),
            (Join-Path $workingDir "gstreamer-1.0")
          )
          
          $foundPlugins = $false
          foreach ($pluginDir in $pluginDirs) {
            if (Test-Path $pluginDir) {
              $plugins = Get-ChildItem -Path $pluginDir -Filter "*.dll"
              Write-Host "  ✓ Found $($plugins.Count) plugins in: $pluginDir" -ForegroundColor Green
              $foundPlugins = $true
              break
            }
          }
          
          if (-not $foundPlugins) {
            Write-Warning "No GStreamer plugins found - audio/video may not work"
          }
          
          # Runtime test
          Write-Host "`n[6/6] Comprehensive runtime execution test..." -ForegroundColor Yellow
          $appLogFile = Join-Path $workingDir "summit_hip_numbers.log"
          
          try {
            # Start the application
            $process = Start-Process -FilePath $exePath.FullName `
                                    -WorkingDirectory $workingDir `
                                    -PassThru `
                                    -WindowStyle Hidden
            
            Write-Host "  Process started (PID: $($process.Id))" -ForegroundColor Green
            
            # Wait for initialization
            Write-Host "  [Test 1/7] Application startup (5s)..." -ForegroundColor Cyan
            Start-Sleep -Seconds 5
            
            if ($process.HasExited) {
              Write-Error "Process crashed during startup with code: $($process.ExitCode)"
              if (Test-Path $appLogFile) {
                Get-Content $appLogFile | Select-Object -Last 50 | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
              }
              exit 1
            }
            Write-Host "    ✓ Application initialized successfully" -ForegroundColor Green
            
            # Prepare for UI automation
            Add-Type -AssemblyName System.Windows.Forms
            Start-Sleep -Milliseconds 500
            
            # Test 2: Arrow navigation (up/down)
            Write-Host "  [Test 2/7] Testing arrow key navigation..." -ForegroundColor Cyan
            [System.Windows.Forms.SendKeys]::SendWait("{DOWN}")
            Start-Sleep -Seconds 2
            [System.Windows.Forms.SendKeys]::SendWait("{DOWN}")
            Start-Sleep -Seconds 2
            [System.Windows.Forms.SendKeys]::SendWait("{UP}")
            Start-Sleep -Seconds 2
            
            if (-not (Get-Process -Id $process.Id -ErrorAction SilentlyContinue)) {
              Write-Error "Process crashed during arrow navigation"
              exit 1
            }
            Write-Host "    ✓ Arrow key navigation working" -ForegroundColor Green
            
            # Test 3: Hip number input (3-digit)
            Write-Host "  [Test 3/7] Testing hip number input (001)..." -ForegroundColor Cyan
            [System.Windows.Forms.SendKeys]::SendWait("0")
            Start-Sleep -Milliseconds 500
            [System.Windows.Forms.SendKeys]::SendWait("0")
            Start-Sleep -Milliseconds 500
            [System.Windows.Forms.SendKeys]::SendWait("1")
            Start-Sleep -Milliseconds 500
            [System.Windows.Forms.SendKeys]::SendWait("{ENTER}")
            Start-Sleep -Seconds 3
            
            if (-not (Get-Process -Id $process.Id -ErrorAction SilentlyContinue)) {
              Write-Error "Process crashed during hip number input"
              exit 1
            }
            Write-Host "    ✓ Hip number input working" -ForegroundColor Green
            
            # Test 4: Multiple video switches
            Write-Host "  [Test 4/7] Testing multiple video switches..." -ForegroundColor Cyan
            [System.Windows.Forms.SendKeys]::SendWait("002{ENTER}")
            Start-Sleep -Seconds 3
            [System.Windows.Forms.SendKeys]::SendWait("003{ENTER}")
            Start-Sleep -Seconds 3
            
            if (-not (Get-Process -Id $process.Id -ErrorAction SilentlyContinue)) {
              Write-Error "Process crashed during video switching"
              exit 1
            }
            Write-Host "    ✓ Video switching working" -ForegroundColor Green
            
            # Test 5: Invalid input handling
            Write-Host "  [Test 5/7] Testing invalid input handling..." -ForegroundColor Cyan
            [System.Windows.Forms.SendKeys]::SendWait("999{ENTER}")
            Start-Sleep -Seconds 2
            
            if (-not (Get-Process -Id $process.Id -ErrorAction SilentlyContinue)) {
              Write-Error "Process crashed on invalid input"
              exit 1
            }
            Write-Host "    ✓ Invalid input handled gracefully" -ForegroundColor Green
            
            # Test 6: Check log for errors
            Write-Host "  [Test 6/7] Analyzing application logs..." -ForegroundColor Cyan
            if (Test-Path $appLogFile) {
              $logContent = Get-Content $appLogFile
              $errors = $logContent | Select-String -Pattern "\[ERROR\]" -SimpleMatch
              $gstErrors = $logContent | Select-String -Pattern "GStreamer Error" -SimpleMatch
              $playbackErrors = $logContent | Select-String -Pattern "Playback error" -SimpleMatch
              
              Write-Host "    Log file size: $((Get-Item $appLogFile).Length) bytes" -ForegroundColor Gray
              Write-Host "    Total log lines: $($logContent.Count)" -ForegroundColor Gray
              
              # Check for video loading
              $videoLoaded = $logContent | Select-String -Pattern "Loading video:" -SimpleMatch
              if ($videoLoaded) {
                Write-Host "    ✓ Videos loaded: $($videoLoaded.Count) attempts" -ForegroundColor Green
              } else {
                Write-Warning "    No video loading detected in logs"
              }
              
              # Check for video playback start
              $videoStarted = $logContent | Select-String -Pattern "Video player started" -SimpleMatch
              if ($videoStarted) {
                Write-Host "    ✓ Video playback started: $($videoStarted.Count) times" -ForegroundColor Green
              } else {
                Write-Warning "    No video playback detected in logs"
              }
              
              # Report errors
              if ($errors.Count -gt 0) {
                Write-Host "    ⚠ Found $($errors.Count) ERROR entries:" -ForegroundColor Yellow
                $errors | Select-Object -First 5 | ForEach-Object { Write-Host "      $_" -ForegroundColor Yellow }
              }
              
              if ($playbackErrors.Count -gt 0) {
                Write-Host "    ⚠ Found $($playbackErrors.Count) playback errors:" -ForegroundColor Yellow
                $playbackErrors | Select-Object -First 3 | ForEach-Object { Write-Host "      $_" -ForegroundColor Yellow }
                
                # Check if errors are critical (streaming stopped, reason not-linked)
                $criticalErrors = $logContent | Select-String -Pattern "reason not-linked"
                if ($criticalErrors.Count -gt 0) {
                  Write-Error "Critical GStreamer errors detected - video pipeline not working"
                  Write-Host "`n=== Last 30 log lines ===" -ForegroundColor Red
                  $logContent | Select-Object -Last 30 | ForEach-Object { Write-Host $_ }
                  Stop-Process -Id $process.Id -Force -ErrorAction SilentlyContinue
                  exit 1
                }
              }
              
              Write-Host "    ✓ Log analysis complete" -ForegroundColor Green
            } else {
              Write-Warning "    Application log file not found"
            }
            
            # Test 7: Graceful exit
            Write-Host "  [Test 7/7] Testing graceful exit..." -ForegroundColor Cyan
            [System.Windows.Forms.SendKeys]::SendWait("{ESC}")
            Start-Sleep -Seconds 2
            
            # Check if process exited gracefully
            if (Get-Process -Id $process.Id -ErrorAction SilentlyContinue) {
              Write-Host "    Process still running, forcing exit..." -ForegroundColor Yellow
              Stop-Process -Id $process.Id -Force
            } else {
              Write-Host "    ✓ Application exited gracefully" -ForegroundColor Green
            }
            
          } catch {
            Write-Error "Runtime test failed: $_"
            Write-Host $_.Exception.Message -ForegroundColor Red
            Write-Host $_.ScriptStackTrace -ForegroundColor Red
            
            # Try to kill process
            if ($process -and -not $process.HasExited) {
              Stop-Process -Id $process.Id -Force -ErrorAction SilentlyContinue
            }
            exit 1
          }
          
          # Display comprehensive logs
          Write-Host "`n============================================" -ForegroundColor Cyan
          Write-Host "  APPLICATION EXECUTION LOGS" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan
          
          if (Test-Path $appLogFile) {
            $logContent = Get-Content $appLogFile
            Write-Host "`nTotal log lines: $($logContent.Count)" -ForegroundColor Gray
            Write-Host "`nFirst 20 lines:" -ForegroundColor Yellow
            $logContent | Select-Object -First 20 | ForEach-Object { Write-Host $_ }
            
            Write-Host "`n..." -ForegroundColor Gray
            
            Write-Host "`nLast 50 lines:" -ForegroundColor Yellow
            $logContent | Select-Object -Last 50 | ForEach-Object { Write-Host $_ }
            
            # Summary statistics
            $infoCount = ($logContent | Select-String -Pattern "\[INFO\]").Count
            $warnCount = ($logContent | Select-String -Pattern "\[WARN\]").Count
            $errorCount = ($logContent | Select-String -Pattern "\[ERROR\]").Count
            
            Write-Host "`n--- Log Summary ---" -ForegroundColor Cyan
            Write-Host "  INFO:  $infoCount" -ForegroundColor Green
            Write-Host "  WARN:  $warnCount" -ForegroundColor Yellow
            Write-Host "  ERROR: $errorCount" -ForegroundColor $(if($errorCount -eq 0){'Green'}else{'Red'})
          } else {
            Write-Warning "Application log file not found at: $appLogFile"
          }
          
          Write-Host "`n============================================" -ForegroundColor Green
          Write-Host "  ✓ ALL INTERFACE TESTS PASSED" -ForegroundColor Green
          Write-Host "============================================" -ForegroundColor Green
      
      - name: Upload Test Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: windows-${{ matrix.variant }}-test-logs
          path: test_portable/**/*.log
          retention-days: 7

  test-linux-portable:
    name: Test Linux Portable (${{ matrix.variant }})
    runs-on: ubuntu-latest
    needs: build-linux
    strategy:
      fail-fast: false
      matrix:
        variant: [full, demo]
    
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          pattern: linux-${{ matrix.variant }}-*
          merge-multiple: true
      
      - name: Comprehensive Linux Test
        run: |
          echo "============================================"
          echo "  LINUX PORTABLE TEST - ${{ matrix.variant }}"
          echo "============================================"
          
          # Extract archive
          echo -e "\n[1/5] Extracting archive..."
          ARCHIVE=$(ls summit_hip_numbers_linux_${{ matrix.variant }}_*.tar.gz | head -n 1)
          if [ -z "$ARCHIVE" ]; then
            echo "ERROR: Archive not found"
            exit 1
          fi
          tar -xzf "$ARCHIVE"
          
          # Validate structure
          echo -e "\n[2/5] Validating structure..."
          find dist/linux-${{ matrix.variant }} -type f -exec ls -lh {} \;
          
          # Find binary
          echo -e "\n[3/5] Locating binary..."
          BINARY=$(find dist/linux-${{ matrix.variant }} -name "summit_hip_numbers*" -type f -executable | head -n 1)
          if [ -z "$BINARY" ]; then
            echo "ERROR: Binary not found"
            exit 1
          fi
          echo "✓ Found: $BINARY"
          
          # Check dependencies
          echo -e "\n[4/5] Checking library dependencies..."
          ldd "$BINARY" || echo "Note: ldd failed (may be statically linked)"
          
          # Quick runtime test
          echo -e "\n[5/5] Runtime test..."
          timeout 5s "$BINARY" --version || echo "✓ Binary executed (timed out as expected)"
          
          echo -e "\n============================================"
          echo "  ✓ ALL TESTS PASSED"
          echo "============================================"

  # ============================================================================
  # BUILD SUMMARY & RELEASE
  # ============================================================================
  
  build-summary:
    name: Build Summary Report
    runs-on: ubuntu-latest
    needs: [test-windows-portable, test-linux-portable, build-macos]
    if: always()
    
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts
      
      - name: Generate Build Summary
        run: |
          cat > BUILD_SUMMARY.md << 'EOF'
          # Summit HIP Numbers - Build Summary
          
          **Build Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Commit:** ${{ github.sha }}
          **Branch:** ${{ github.ref_name }}
          
          ## Build Artifacts
          
          EOF
          
          echo "### Windows Builds" >> BUILD_SUMMARY.md
          find all-artifacts -name "*windows*" -type f | while read file; do
            SIZE=$(du -h "$file" | cut -f1)
            echo "- $(basename "$file") ($SIZE)" >> BUILD_SUMMARY.md
          done
          
          echo -e "\n### Linux Builds" >> BUILD_SUMMARY.md
          find all-artifacts -name "*linux*" -type f | while read file; do
            SIZE=$(du -h "$file" | cut -f1)
            echo "- $(basename "$file") ($SIZE)" >> BUILD_SUMMARY.md
          done
          
          echo -e "\n### macOS Builds" >> BUILD_SUMMARY.md
          find all-artifacts -name "*macos*" -type f | while read file; do
            SIZE=$(du -h "$file" | cut -f1)
            echo "- $(basename "$file") ($SIZE)" >> BUILD_SUMMARY.md
          done
          
          cat BUILD_SUMMARY.md
      
      - name: Upload Summary
        uses: actions/upload-artifact@v4
        with:
          name: build-summary
          path: BUILD_SUMMARY.md

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [test-windows-portable, test-linux-portable, build-macos]
    if: github.event_name == 'release'
    permissions:
      contents: write
    
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Prepare Release Files
        run: |
          mkdir -p release_files
          
          # Copy all distribution archives
          find artifacts -name "*.zip" -exec cp {} release_files/ \;
          find artifacts -name "*.tar.gz" -exec cp {} release_files/ \;
          find artifacts -name "*.dmg" -exec cp {} release_files/ \;
          find artifacts -name "*.exe" -exec cp {} release_files/ \;
          
          # List release files
          echo "Release files:"
          ls -lh release_files/
      
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: release_files/*
          token: ${{ secrets.GITHUB_TOKEN }}
          generate_release_notes: true
          fail_on_unmatched_files: true